<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>军棋对战（局域网专属版）</title>
<style>
/* 完整样式保留，仅适配局域网界面 */
*{box-sizing:border-box;margin:0;padding:0;font-family:Microsoft YaHei,sans-serif}
body{background:#f4f6f8;padding:10px}
.container{max-width:700px;margin:0 auto;background:#fff;border-radius:12px;padding:20px;box-shadow:0 2px 12px rgba(0,0,0,0.1)}
.title{text-align:center;font-size:24px;font-weight:bold;margin-bottom:16px;color:#222}
.btn-group{display:flex;justify-content:center;gap:10px;margin-bottom:12px;flex-wrap:wrap}
.btn{padding:10px 20px;border:none;border-radius:8px;background:#1677ff;color:#fff;font-size:15px;cursor:pointer;transition:background 0.2s}
.btn:hover{background:#096dd9}
.btn:disabled{background:#d9d9d9;cursor:not-allowed;color:#8c8c8c}
.btn-mode{background:#14c9c9}
.btn-start{background:#52c1a6}
.msg-box{text-align:center;padding:12px;border-radius:8px;margin:10px 0;font-size:15px}
.msg-info{background:#e6f7ff;color:#0066cc}
.msg-success{background:#f0fff4;color:#008800}
.msg-error{background:#fff1f0;color:#cc0000}
.msg-warn{background:#fffbe6;color:#faad14}
.panel{display:none;text-align:center;padding:16px;border:2px solid #1677ff;border-radius:8px;margin:10px auto;max-width:500px;background:#f7fcff}
.panel-title{font-size:16px;margin-bottom:12px;font-weight:bold}
.mode-panel{border-color:#14c9c9;background:#f0fefe}
.deploy-panel{border-color:#faad14;background:#fffbf5}
.conn-panel{border-color:#ff7d00;background:#fff9f0}
.lan-panel{display:none;text-align:center;padding:12px;border:2px solid #1677ff;border-radius:8px;margin:10px auto;max-width:400px;background:#f7fcff}
.lan-info{font-size:18px;font-weight:bold;color:#1677ff;margin:10px 0}
.lan-input{padding:8px 12px;border:2px solid #1677ff;border-radius:6px;font-size:16px;width:200px;margin-right:10px;text-align:center}
.bluetooth-panel{display:none;text-align:center;padding:12px;border:2px solid #ff7d00;background:#fff9f0;border-radius:8px;margin:10px auto;max-width:400px}
.bluetooth-device-list{max-height:150px;overflow-y:auto;margin:10px 0;text-align:left;padding:10px;border:1px solid #ddd;border-radius:6px}
.bluetooth-device-item{padding:6px;margin:4px 0;border-radius:4px;cursor:pointer}
.bluetooth-device-item:hover{background:#e6f7ff}
.connect-status{text-align:center;font-size:16px;margin:10px auto;padding:8px;border-radius:8px;max-width:400px;font-weight:bold}
.status-disconnected{background:#fff1f0;color:#cc0000}
.status-waiting{background:#f5f0ff;color:#722ed1}
.status-connecting{background:#fffbe6;color:#faad14}
.status-connected{background:#f0fff4;color:#008800}
.info-bar{display:flex;justify-content:space-between;max-width:650px;margin:10px auto;font-size:15px;padding:0 8px;flex-wrap:wrap;gap:10px}
.info-bar div{flex:1;min-width:12px;text-align:center}
.info-bar span{font-weight:bold;color:#1677ff}
.board-wrap{max-width:600px;margin:20px auto;position:relative}
.board{
  width:100%;
  aspect-ratio: 5 / 7;
  background:#fdfbf6;
  border:3px solid #333;
  position:relative;
  border-radius:4px;
  overflow:hidden;
}
.cell{
  position:absolute;
  width:20%;
  height:7.692%;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  border:1px solid #999;
  background:#fff;
  z-index:1;
  cursor:pointer;
}
.cell-selected{
  background:#d4edda !important;
  border:2px solid #28a745 !important;
}
.cell-station{background:#fff;border:1px solid #999}
.cell-camp{background:#e0f0ff;border:2px solid #0066cc;border-radius:50%;z-index:2;font-weight:bold;color:#0066cc}
.cell-home{background:#ff4444;border:2px solid #cc0000;color:white;font-weight:bold;z-index:2}
.cell-front{background:#f0f0f0;border:2px solid #666;font-weight:bold;color:#333}
.piece{
  position:absolute;
  width:18%;
  height:6.8%;
  left:1%;
  top:0.4%;
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:6px;
  font-size:12px;
  font-weight:bold;
  border:2px solid #fff;
  cursor:pointer;
  z-index:5;
  box-shadow:0 1px 4px rgba(0,0,0,0.2);
  transition:transform 0.1s;
}
.piece-red{background:#e63946;color:#fff}
.piece-black{background:#222;color:#fff}
.piece-unknown{background:#bbb;color:#222;font-size:11px}
.piece-selected{
  transform:scale(1.1);
  border:3px solid #ffc107;
  box-shadow:0 0 10px rgba(255,193,7,0.8);
}
.piece-fixed{cursor:not-allowed;opacity:0.9}
.deploy-tips{
  position:absolute;
  top:10px;
  left:10px;
  background:rgba(0,0,0,0.7);
  color:white;
  padding:8px;
  border-radius:6px;
  font-size:12px;
  z-index:100;
  display:none;
}
.over-layer{
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:100%;
  background:rgba(0,0,0,0.7);
  display:none;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  color:white;
  z-index:999;
  border-radius:4px;
}
.over-text{font-size:28px;font-weight:bold;margin-bottom:20px}
.over-btn{padding:12px 24px;background:#1677ff;color:white;border:none;border-radius:8px;cursor:pointer;font-size:16px}
</style>
</head>
<body>
<div class="container">
  <div class="title">军棋对战（局域网专属版）</div>
  <div class="btn-group">
    <button class="btn btn-mode" id="btnModeSelect">选择玩法模式</button>
    <button class="btn" id="btnHost">我是红方（主机）</button>
    <button class="btn" id="btnClient">我是黑方（客户端）</button>
    <button class="btn btn-start" id="btnStartGame" disabled>开始游戏</button>
  </div>
  <div class="msg-box msg-info" id="msgBox">请先选择玩法模式，再选择身份</div>
  
  <div class="connect-status status-disconnected" id="connectStatus">
    联机状态：未连接
  </div>
  
  <div class="panel mode-panel" id="modePanel">
    <div class="panel-title">选择对局玩法</div>
    <button class="btn" onclick="setGameMode(1)">暗棋（线下经典）</button>
    <button class="btn" onclick="setGameMode(2)">明棋（新手入门）</button>
    <button class="btn" onclick="setGameMode(3)">翻棋（线上主流）</button>
  </div>
  
  <div class="panel deploy-panel" id="deployPanel">
    <div class="panel-title">暗棋排兵布阵（遵循布局规则）</div>
    <div style="font-size:14px;color:#cc6600;margin-bottom:10px">
      规则提示：<br>
      1. 军旗必须放大本营 | 2. 炸弹不可放第一排 | 3. 地雷仅可放最后两排 | 4. 行营不可放棋子<br>
      操作：点击棋子选择，再次点击目标格子放置
    </div>
    <button class="btn" onclick="startDeploy()">进入布阵界面</button>
    <button class="btn" onclick="confirmDeploy()" disabled id="btnConfirmDeploy">确认布阵</button>
  </div>
  
  <!-- 局域网联机面板 -->
  <div class="panel conn-panel" id="connPanel">
    <div class="panel-title">选择局域网联机方式</div>
    <button class="btn" id="btnLanPeer" onclick="startHost(3)">局域网点对点联机（推荐）</button>
    <button class="btn" onclick="startHost(4)">蓝牙联机（需HTTPS/localhost）</button>
  </div>
  
  <!-- 红方主机局域网信息面板 -->
  <div class="lan-panel" id="hostLanPanel">
    <div class="panel-title">红方主机（局域网信息）</div>
    <div>本机局域网IP：</div>
    <div class="lan-info" id="hostIpInfo">检测中...</div>
    <div style="margin:10px 0">黑方请输入上方IP进行连接</div>
    <button class="btn" onclick="startLanHost()">启动局域网联机服务</button>
  </div>
  
  <!-- 黑方客户端连接面板 -->
  <div class="lan-panel" id="clientLanPanel">
    <div class="panel-title">黑方客户端（连接主机）</div>
    <div>输入红方主机局域网IP：</div>
    <input type="text" class="lan-input" id="hostIpInput" placeholder="如：192.168.1.100" value="192.168.1.100">
    <button class="btn" onclick="connectLanClient()">连接主机</button>
  </div>
  
  <!-- 蓝牙面板保留 -->
  <div class="bluetooth-panel" id="bluetoothPanel">
    <div class="panel-title">蓝牙连接控制（真实API）</div>
    <button class="btn" onclick="scanBluetoothDevices()">扫描蓝牙设备</button>
    <div class="bluetooth-device-list" id="bluetoothDeviceList">
      请点击扫描按钮查找设备（需蓝牙开启）...
    </div>
    <button class="btn" style="margin-top:10px" onclick="connectBluetoothDevice()" disabled id="btnConnectBluetooth">连接选中设备</button>
    <button class="btn" style="margin-top:10px" onclick="disconnectBluetooth()">断开蓝牙连接</button>
  </div>
  
  <div class="info-bar">
    <div>当前玩法：<span id="showMode">未选择</span></div>
    <div>当前回合：<span id="showTurn">未开始</span></div>
    <div>通信模式：<span id="showConn">未选择</span></div>
    <div>游戏状态：<span id="showStatus">未开始</span></div>
  </div>
  
  <div class="board-wrap">
    <div class="board" id="board">
      <div class="deploy-tips" id="deployTips">排兵布阵中：点击棋子选择，再次点击目标格子放置</div>
      <div class="over-layer" id="overLayer">
        <div class="over-text" id="overText">红方胜利！</div>
        <button class="over-btn" onclick="restartGame()">重新开始</button>
      </div>
    </div>
  </div>
</div>

<!-- 更换为更稳定的CDN链接，并增加加载失败处理 -->
<script src="https://unpkg.com/simple-peer@9.11.1/dist/simplepeer.min.js" onload="onSimplePeerLoaded()" onerror="onSimplePeerLoadError()"></script>

<script>
// 标记SimplePeer是否加载成功
let isSimplePeerLoaded = false;

// SimplePeer加载成功回调
function onSimplePeerLoaded() {
  isSimplePeerLoaded = true;
  console.log('SimplePeer库加载成功');
  // 启用局域网联机按钮
  document.getElementById('btnLanPeer').disabled = false;
}

// SimplePeer加载失败回调
function onSimplePeerLoadError() {
  isSimplePeerLoaded = false;
  showMessage('局域网联机库加载失败，无法使用点对点联机功能', 'error');
  // 禁用局域网联机按钮
  document.getElementById('btnLanPeer').disabled = true;
}

// ===================== 全局配置（局域网专属版） =====================
const CONN_MODE = { LAN_PEER:3, BLUETOOTH:4 }
const GAME_MODE = { DARK:1, BRIGHT:2, FLIP:3 }
const PIECE_RANK = {
  '司令':10, '军长':9, '师长':8, '旅长':7, '团长':6,
  '营长':5, '连长':4, '排长':3, '工兵':2, '炸弹':1,
  '地雷':0, '军旗':-1
}
const PIECE_CONFIG = [
  {name:'军旗', count:1, movable:false, deployRule:{mustHome:true}},
  {name:'地雷', count:3, movable:false, deployRule:{onlyLastTwoRows:true}},
  {name:'炸弹', count:2, movable:true, deployRule:{noFirstRow:true}},
  {name:'司令', count:1, movable:true, deployRule:{}},
  {name:'军长', count:1, movable:true, deployRule:{}},
  {name:'师长', count:2, movable:true, deployRule:{}},
  {name:'旅长', count:2, movable:true, deployRule:{}},
  {name:'团长', count:2, movable:true, deployRule:{}},
  {name:'营长', count:2, movable:true, deployRule:{}},
  {name:'连长', count:3, movable:true, deployRule:{}},
  {name:'排长', count:3, movable:true, deployRule:{}},
  {name:'工兵', count:3, movable:true, deployRule:{}}
]

// 全局状态
let gameMode = 0
let connMode = 0
let isHost = false
let localLanIp = '' // 本机局域网IP
let currentTurn = "red"
let gameOver = false
let selectedPiece = null
let pieces = []
let cells = []
let isDeployPhase = false
let deployComplete = false
let cellWidth = 20
let cellHeight = 100/13

// 联机核心状态（局域网版）
let connectStatus = 'disconnected' // disconnected/waiting/connecting/connected
let isConnected = false
let peerConnection = null // 局域网点对点连接实例
let bluetoothDevice = null // 蓝牙设备实例
let selectedBluetoothDevice = null // 选中的蓝牙设备

// ===================== 页面初始化 =====================
window.onload = () => {
  // 初始禁用局域网联机按钮，等待库加载
  document.getElementById('btnLanPeer').disabled = true;
  
  // 获取本机局域网IP（仅局域网）
  getLocalLanIp()
  buildStandardBoard()
  bindButtonEvents()
  updateConnectStatus(connectStatus)
  
  // 检查蓝牙支持
  if (!navigator.bluetooth) {
    showMessage('当前浏览器不支持蓝牙API，请使用Chrome/Edge', 'error')
    document.querySelectorAll('.btn[onclick="startHost(4)"]')[0].disabled = true
  }
  
  // 如果SimplePeer已经加载（缓存），立即启用按钮
  if (window.SimplePeer) {
    onSimplePeerLoaded();
  }
}

// ===================== 局域网工具函数 =====================
/**
 * 获取本机局域网IP（仅局域网，不获取公网IP）
 */
function getLocalLanIp() {
  const ipInfoEl = document.getElementById('hostIpInfo')
  
  // 方法1：通过RTCPeerConnection获取局域网IP
  const RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
  if (RTCPeerConnection) {
    const pc = new RTCPeerConnection({ iceServers: [] });
    pc.createDataChannel('');
    pc.createOffer().then(offer => pc.setLocalDescription(offer)).catch(err => {
      console.error('获取IP失败:', err);
      // 降级方案
      localLanIp = '192.168.1.100';
      ipInfoEl.innerText = localLanIp;
      showMessage('无法自动检测局域网IP，请手动确认', 'warn');
    });
    
    pc.onicecandidate = (e) => {
      if (!e.candidate) return;
      // 只提取局域网IP（192.168/172.16/10.开头）
      const ipRegex = /(192\.168\.\d+\.\d+|172\.1[6-9]\.\d+\.\d+|172\.2[0-9]\.\d+\.\d+|172\.3[0-1]\.\d+\.\d+|10\.\d+\.\d+\.\d+)/;
      const ipMatch = e.candidate.candidate.match(ipRegex);
      
      if (ipMatch && ipMatch[1]) {
        localLanIp = ipMatch[1];
        ipInfoEl.innerText = localLanIp;
        pc.onicecandidate = null;
      }
    };
  } else {
    // 降级方案：默认IP
    localLanIp = '192.168.1.100';
    ipInfoEl.innerText = localLanIp;
    showMessage('无法自动检测局域网IP，请手动确认', 'warn');
  }
}

// ===================== 联机状态管理 =====================
function updateConnectStatus(status) {
  connectStatus = status
  const statusEl = document.getElementById('connectStatus')
  statusEl.className = `connect-status status-${status}`
  
  const statusTextMap = {
    disconnected: '联机状态：未连接',
    waiting: '联机状态：等待客户端连接（主机）',
    connecting: '联机状态：正在连接...',
    connected: '联机状态：已连接（局域网）'
  }
  statusEl.innerText = statusTextMap[status]
  isConnected = status === 'connected'
  
  // 更新开始游戏按钮
  updateStartButtonStatus()
}

function updateStartButtonStatus() {
  document.getElementById('btnStartGame').disabled = !(deployComplete && isConnected)
}

function showMessage(text, type = 'info') {
  const msgBox = document.getElementById('msgBox')
  msgBox.innerText = text
  msgBox.className = `msg-box msg-${type}`
  setTimeout(() => {
    if (msgBox.innerText === text && connectStatus !== 'waiting') {
      msgBox.className = 'msg-box msg-info'
      msgBox.innerText = '等待操作...'
    }
  }, 3000)
}

// ===================== 局域网点对点联机（核心） =====================
/**
 * 红方主机启动局域网联机服务（无STUN，纯局域网）
 */
function startLanHost() {
  // 检查SimplePeer是否加载
  if (!isSimplePeerLoaded || !window.SimplePeer) {
    showMessage('局域网联机库未加载，无法启动主机', 'error');
    return;
  }
  
  try {
    // 关闭已有连接
    if (peerConnection) {
      peerConnection.destroy()
      peerConnection = null
    }
    
    // 创建局域网点对点连接（主机，禁用STUN）
    peerConnection = new window.SimplePeer({
      initiator: false, // 主机作为被动方
      trickle: false,    // 禁用trickle ICE
      config: {
        iceServers: [] // 局域网内无需STUN服务器！
      }
    })
    
    // 更新状态为等待连接
    updateConnectStatus('waiting')
    showMessage(`局域网主机已启动（IP：${localLanIp}），等待黑方连接...`, 'success')
    
    // 监听signal事件（存储连接信息）
    peerConnection.on('signal', (data) => {
      // 局域网内：将signal数据存储到localStorage，供客户端读取
      localStorage.setItem(`lan_peer_signal_${localLanIp}`, JSON.stringify(data))
    })
    
    // 连接成功
    peerConnection.on('connect', () => {
      updateConnectStatus('connected')
      showMessage('局域网联机成功！', 'success')
    })
    
    // 接收消息
    peerConnection.on('data', (data) => {
      try {
        const msg = JSON.parse(data.toString())
        handleGameMessage(msg)
      } catch (e) {
        console.error('解析消息失败:', e);
        showMessage('接收消息格式错误', 'error');
      }
    })
    
    // 连接关闭
    peerConnection.on('close', () => {
      showMessage('局域网连接已关闭', 'warn')
      updateConnectStatus('disconnected')
      peerConnection = null
    })
    
    // 错误处理
    peerConnection.on('error', (err) => {
      showMessage(`局域网联机错误: ${err.message}`, 'error')
      updateConnectStatus('disconnected')
      peerConnection = null
    })
    
  } catch (e) {
    showMessage(`启动局域网主机失败: ${e.message}`, 'error')
    updateConnectStatus('disconnected')
  }
}

/**
 * 黑方客户端连接局域网主机
 */
function connectLanClient() {
  // 检查SimplePeer是否加载
  if (!isSimplePeerLoaded || !window.SimplePeer) {
    showMessage('局域网联机库未加载，无法连接主机', 'error');
    return;
  }
  
  try {
    const hostIp = document.getElementById('hostIpInput').value.trim()
    if (!hostIp) {
      showMessage('请输入红方主机局域网IP', 'error')
      return
    }
    
    // 验证IP格式（局域网IP）
    const lanIpRegex = /^(192\.168\.\d+\.\d+|172\.1[6-9]\.\d+\.\d+|172\.2[0-9]\.\d+\.\d+|172\.3[0-1]\.\d+\.\d+|10\.\d+\.\d+\.\d+)$/
    if (!lanIpRegex.test(hostIp)) {
      showMessage('请输入有效的局域网IP（如192.168.1.100）', 'error')
      return
    }
    
    // 更新状态为正在连接
    updateConnectStatus('connecting')
    showMessage(`正在连接局域网主机（IP：${hostIp}）...`, 'info')
    
    // 获取主机的signal数据（局域网内通过localStorage共享，实际可通过IP直接通信）
    const hostSignal = localStorage.getItem(`lan_peer_signal_${hostIp}`)
    if (!hostSignal) {
      showMessage('未找到该IP的主机，请确认：1.主机已启动 2.IP正确 3.同一局域网', 'error')
      updateConnectStatus('disconnected')
      return
    }
    
    // 关闭已有连接
    if (peerConnection) {
      peerConnection.destroy()
      peerConnection = null
    }
    
    // 创建局域网点对点连接（客户端，禁用STUN）
    peerConnection = new window.SimplePeer({
      initiator: true,   // 客户端作为主动方
      trickle: false,
      config: {
        iceServers: [] // 局域网内无需STUN服务器！
      }
    })
    
    // 监听signal事件，发送连接请求
    peerConnection.on('signal', (data) => {
      try {
        peerConnection.signal(JSON.parse(hostSignal))
      } catch (e) {
        console.error('发送连接请求失败:', e);
        showMessage('连接请求格式错误', 'error');
        updateConnectStatus('disconnected');
      }
    })
    
    // 连接成功
    peerConnection.on('connect', () => {
      updateConnectStatus('connected')
      showMessage(`成功连接到局域网主机（IP：${hostIp}）！`, 'success')
    })
    
    // 接收消息
    peerConnection.on('data', (data) => {
      try {
        const msg = JSON.parse(data.toString())
        handleGameMessage(msg)
      } catch (e) {
        console.error('解析消息失败:', e);
        showMessage('接收消息格式错误', 'error');
      }
    })
    
    // 连接关闭
    peerConnection.on('close', () => {
      showMessage('局域网连接已关闭', 'warn')
      updateConnectStatus('disconnected')
      peerConnection = null
    })
    
    // 错误处理
    peerConnection.on('error', (err) => {
      showMessage(`连接失败: ${err.message}`, 'error')
      updateConnectStatus('disconnected')
      peerConnection = null
    })
    
  } catch (e) {
    showMessage(`连接局域网主机失败: ${e.message}`, 'error')
    updateConnectStatus('disconnected')
  }
}

/**
 * 发送游戏消息（局域网内）
 */
function sendGameMessage(data) {
  if (!peerConnection || !peerConnection.connected) {
    showMessage('局域网未连接，无法发送消息', 'error')
    return
  }
  
  try {
    peerConnection.send(JSON.stringify({
      from: isHost ? 'red' : 'black',
      data: data
    }))
  } catch (e) {
    showMessage(`发送消息失败: ${e.message}`, 'error');
  }
}

/**
 * 处理接收的游戏消息
 */
function handleGameMessage(msg) {
  try {
    if (msg.data.type === 'piece_move') {
      // 同步对方棋子移动
      const piece = pieces.find(p => p.id === msg.data.pieceId)
      if (piece) {
        piece.row = msg.data.row
        piece.col = msg.data.col
        renderPieces()
      }
    }
    if (msg.data.type === 'turn_change') {
      // 同步回合切换
      currentTurn = msg.data.turn
      updateGameInfo()
      showMessage(`回合切换：${currentTurn === 'red' ? '红方' : '黑方'}行动`, 'info')
    }
    if (msg.data.type === 'game_over') {
      // 同步游戏结束
      gameOver = true
      showGameOver(msg.data.winner)
    }
    if (msg.data.type === 'game_start') {
      // 同步游戏开始
      currentTurn = msg.data.turn
      updateGameInfo()
      renderPieces()
    }
  } catch (e) {
    console.error('处理游戏消息失败:', e);
    showMessage('处理游戏消息出错', 'error');
  }
}

// ===================== 蓝牙功能（保留原有） =====================
async function scanBluetoothDevices() {
  try {
    showMessage('正在扫描蓝牙设备，请在系统弹窗中允许权限', 'info')
    const deviceListEl = document.getElementById('bluetoothDeviceList')
    deviceListEl.innerHTML = '扫描中...'
    
    // 调用浏览器蓝牙扫描API
    const devices = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: ['generic_access']
    })
    
    // 显示扫描结果
    deviceListEl.innerHTML = ''
    const deviceItem = document.createElement('div')
    deviceItem.className = 'bluetooth-device-item'
    deviceItem.innerText = `设备名称：${devices.name || '未知设备'} | ID：${devices.id}`
    deviceItem.dataset.deviceId = devices.id
    deviceItem.onclick = () => {
      document.querySelectorAll('.bluetooth-device-item').forEach(i => i.style.background = '')
      deviceItem.style.background = '#1677ff'
      deviceItem.style.color = '#fff'
      selectedBluetoothDevice = devices
      document.getElementById('btnConnectBluetooth').disabled = false
      showMessage(`已选中蓝牙设备：${devices.name || '未知设备'}`, 'info')
    }
    deviceListEl.appendChild(deviceItem)
    
    showMessage('蓝牙设备扫描完成，请选择并连接', 'success')
  } catch (err) {
    showMessage(`蓝牙扫描失败: ${err.message}`, 'error')
    if (err.name === 'NotFoundError') {
      showMessage('未找到蓝牙设备，请确保设备已开启并可被发现', 'error')
    } else if (err.name === 'SecurityError') {
      showMessage('蓝牙权限被拒绝，请允许浏览器访问蓝牙', 'error')
    }
  }
}

async function connectBluetoothDevice() {
  if (!selectedBluetoothDevice) {
    showMessage('请先选择蓝牙设备', 'error')
    return
  }
  
  try {
    updateConnectStatus('connecting')
    showMessage(`正在连接蓝牙设备：${selectedBluetoothDevice.name || '未知设备'}`, 'info')
    
    // 连接蓝牙设备GATT服务器
    const bluetoothServer = await selectedBluetoothDevice.gatt.connect()
    bluetoothDevice = selectedBluetoothDevice
    
    // 连接成功
    updateConnectStatus('connected')
    showMessage(`蓝牙设备连接成功：${selectedBluetoothDevice.name || '未知设备'}`, 'success')
    
    // 监听断开事件
    selectedBluetoothDevice.addEventListener('gattserverdisconnected', () => {
      showMessage('蓝牙设备已断开连接', 'warn')
      disconnectBluetooth()
    })
  } catch (err) {
    showMessage(`蓝牙连接失败: ${err.message}`, 'error')
    updateConnectStatus('disconnected')
  }
}

function disconnectBluetooth() {
  try {
    if (bluetoothDevice && bluetoothDevice.gatt.connected) {
      bluetoothDevice.gatt.disconnect()
    }
    bluetoothDevice = null
    selectedBluetoothDevice = null
    updateConnectStatus('disconnected')
    document.getElementById('btnConnectBluetooth').disabled = true
    document.querySelectorAll('.bluetooth-device-item').forEach(i => i.style.background = '')
    showMessage('已断开蓝牙连接', 'info')
  } catch (err) {
    showMessage(`断开蓝牙失败: ${err.message}`, 'error')
  }
}

// ===================== 棋盘&游戏逻辑（保留原有） =====================
function buildStandardBoard() {
  const board = document.getElementById('board')
  board.innerHTML = `
    <div class="deploy-tips" id="deployTips">排兵布阵中：点击棋子可重新选择移动</div>
    <div class="over-layer" id="overLayer">
      <div class="over-text" id="overText">红方胜利！</div>
      <button class="over-btn" onclick="restartGame()">重新开始</button>
    </div>
  `;
  cells = []
  cellWidth = 20
  cellHeight = 100/13
  let cellId = 0

  const BOARD_LAYOUT = [
    ['S','H','S','H','S'],
    ['S','S','S','S','S'],
    ['S','C','S','C','S'],
    ['S','S','C','S','S'],
    ['S','C','S','C','S'],
    ['S','S','S','S','S'],
    ['F','F','F','F','F'],
    ['S','S','S','S','S'],
    ['S','C','S','C','S'],
    ['S','S','C','S','S'],
    ['S','C','S','C','S'],
    ['S','S','S','S','S'],
    ['S','H','S','H','S']
  ]

  for (let row = 0; row < 13; row++) {
    for (let col = 0; col < 5; col++) {
      const cellType = BOARD_LAYOUT[row][col]
      const cell = document.createElement('div')
      cell.className = 'cell'
      cell.style.left = `${col * cellWidth}%`
      cell.style.top = `${row * cellHeight}%`
      cell.dataset.type = cellType
      cell.dataset.row = row
      cell.dataset.col = col
      cell.dataset.id = cellId

      if (cellType === 'S') { cell.className += ' cell-station'; cell.innerText = '兵站' }
      if (cellType === 'C') { cell.className += ' cell-camp'; cell.innerText = '行营' }
      if (cellType === 'H') { cell.className += ' cell-home'; cell.innerText = '大本营' }
      if (cellType === 'F') { cell.className += ' cell-front'; cell.innerText = (col===1)?'红\n方':(col===3)?'黑\n方':'前线' }

      cell.onclick = () => {
        if (isDeployPhase) handleDeployCellClick(cell)
        else handleCellClick(cell)
      }

      board.appendChild(cell)
      cells.push({ id:cellId, row, col, type:cellType, element:cell, isRedArea:row<6, isBlackArea:row>6, isPublicArea:row===6 })
      cellId++
    }
  }
}

function bindButtonEvents() {
  document.getElementById('btnModeSelect').onclick = () => {
    document.getElementById('modePanel').style.display = 'block'
    showMessage('请选择游戏玩法模式','info')
  }
  
  document.getElementById('btnHost').onclick = () => {
    isHost = true
    document.getElementById('connPanel').style.display = 'block'
    document.getElementById('hostLanPanel').style.display = 'block'
    document.getElementById('clientLanPanel').style.display = 'none'
    document.getElementById('bluetoothPanel').style.display = 'none'
    showMessage('你是红方（主机），请选择局域网联机方式并完成联机', 'info')
    updateGameInfo()
  }
  
  document.getElementById('btnClient').onclick = () => {
    isHost = false
    document.getElementById('connPanel').style.display = 'block'
    document.getElementById('hostLanPanel').style.display = 'none'
    document.getElementById('clientLanPanel').style.display = 'block'
    document.getElementById('bluetoothPanel').style.display = 'none'
    showMessage('你是黑方（客户端），请选择局域网联机方式并连接主机', 'info')
    updateGameInfo()
  }
  
  document.getElementById('btnStartGame').onclick = () => {
    if (!gameOver && deployComplete && isConnected) {
      showMessage('游戏开始！红方先行','success')
      currentTurn = 'red'
      updateGameInfo()
      renderPieces()
      // 发送游戏开始消息给对方
      sendGameMessage({ type: 'game_start', turn: 'red' })
    }
  }
}

function setGameMode(mode) {
  gameMode = mode
  document.getElementById('modePanel').style.display = 'none'
  initPieces()
  showMessage(`已选择${mode===1?'暗棋':mode===2?'明棋':'翻棋'}模式`,'success')
  updateGameInfo()
}

function startHost(mode) {
  connMode = mode
  document.getElementById('connPanel').style.display = 'none'
  
  if (mode === CONN_MODE.LAN_PEER) {
    if (isHost) {
      document.getElementById('hostLanPanel').style.display = 'block'
      document.getElementById('clientLanPanel').style.display = 'none'
    } else {
      document.getElementById('clientLanPanel').style.display = 'block'
      document.getElementById('hostLanPanel').style.display = 'none'
    }
    showMessage(`已选择局域网点对点联机，主机请启动服务，客户端请输入主机IP连接`, 'success')
  } else if (mode === CONN_MODE.BLUETOOTH) {
    document.getElementById('bluetoothPanel').style.display = 'block'
    document.getElementById('hostLanPanel').style.display = 'none'
    document.getElementById('clientLanPanel').style.display = 'none'
    showMessage(`已选择蓝牙信道，请扫描并连接设备（需蓝牙开启）`, 'success')
  }
  
  updateGameInfo()
}

function initPieces() {
  pieces = []
  let pid = 0
  PIECE_CONFIG.forEach(c=>{for(let i=0;i<c.count;i++)pieces.push({id:pid++,color:'red',name:c.name,row:-1,col:-1,isCaptured:false,isMovable:c.movable,isRevealed:gameMode===2,deployRule:c.deployRule})})
  PIECE_CONFIG.forEach(c=>{for(let i=0;i<c.count;i++)pieces.push({id:pid++,color:'black',name:c.name,row:-1,col:-1,isCaptured:false,isMovable:c.movable,isRevealed:gameMode===2,deployRule:c.deployRule})})

  if(gameMode===3){
    deployFlipPieces();
    deployComplete=true;
    updateStartButtonStatus()
  } else {
    gameMode===1?showDeployPanel():autoDeployPieces();
    deployComplete=gameMode===2;
    updateStartButtonStatus()
  }
}

function showDeployPanel() {
  document.getElementById('deployPanel').style.display = 'block'
  document.getElementById('deployTips').style.display = 'block'
  isDeployPhase = true
  showMessage('进入布阵，已落下的棋子可点击重新移动','info')
}

function startDeploy() {
  document.querySelectorAll('.piece').forEach(p=>p.remove())
  const my = isHost?'red':'black'
  my==='red' ? deployRedPiecesForDeploy() : deployBlackPiecesForDeploy()
  showMessage('点击棋子（包括已落下的）可重新选择','info')
}

function deployRedPiecesForDeploy() {
  const board = document.getElementById('board')
  let sx = 5, sy = 70
  pieces.filter(p=>p.color==='red').forEach((p,idx)=>{
    if(p.element)p.element.remove()
    const el = document.createElement('div')
    el.className = 'piece piece-red'
    el.innerText = p.name
    if(p.row === -1 || p.col === -1){
      el.style.left = `${sx + (idx%5)*18}%`
      el.style.top = `${sy + Math.floor(idx/5)*7}%`
    }else{
      el.style.left = `${p.col*cellWidth+1}%`
      el.style.top = `${p.row*cellHeight+0.4}%`
    }
    el.dataset.pieceId = p.id
    el.onclick = e=>{e.preventDefault();handleDeployPieceClick(p)}
    board.appendChild(el)
    p.element = el
  })
}

function deployBlackPiecesForDeploy() {
  const board = document.getElementById('board')
  let sx =5, sy=5
  pieces.filter(p=>p.color==='black').forEach((p,idx)=>{
    if(p.element)p.element.remove()
    const el = document.createElement('div')
    el.className = 'piece piece-black'
    el.innerText = p.name
    if(p.row === -1 || p.col === -1){
      el.style.left = `${sx + (idx%5)*18}%`
      el.style.top = `${sy + Math.floor(idx/5)*7}%`
    }else{
      el.style.left = `${p.col*cellWidth+1}%`
      el.style.top = `${p.row*cellHeight+0.4}%`
    }
    el.dataset.pieceId = p.id
    el.onclick = e=>{e.preventDefault();handleDeployPieceClick(p)}
    board.appendChild(el)
    p.element = el
  })
}

function handleDeployPieceClick(piece) {
  if(!isDeployPhase)return
  if(selectedPiece && selectedPiece.element) selectedPiece.element.classList.remove('piece-selected')
  selectedPiece = piece
  if(piece.element) piece.element.classList.add('piece-selected')
  showMessage(`已选中【${piece.name}】，可点新位置重新放置`,'info')
}

function handleDeployCellClick(cell) {
  if(!isDeployPhase || !selectedPiece)return
  const tr = +cell.dataset.row
  const tc = +cell.dataset.col

  if(!validateDeployRule(selectedPiece, tr, tc)){
    showMessage('不符合布阵规则','error')
    return
  }

  selectedPiece.row = tr
  selectedPiece.col = tc
  selectedPiece.element.style.left = `${tc*cellWidth+1}%`
  selectedPiece.element.style.top = `${tr*cellHeight+0.4}%`
  selectedPiece.element.classList.remove('piece-selected')
  selectedPiece = null
  showMessage('棋子已重新放置','success')
  checkAllPiecesDeployed()
}

function validateDeployRule(p, r, c) {
  if(r<0||r>=13||c<0||c>=5)return false
  const redSide = r<6, blackSide=r>6
  if(p.color==='red'&&!redSide || p.color==='black'&&!blackSide)return false
  const cell = cells.find(x=>x.row===r&&x.col===c)
  if(!cell || cell.type==='C'||cell.type==='F')return false
  
  if(p.name === '军旗' && cell.type !== 'H') return false
  if(p.name === '炸弹') {
    if((p.color === 'red' && r === 0) || (p.color === 'black' && r === 12)) return false
  }
  if(p.name === '地雷') {
    if(p.color === 'red' && !(r === 4 || r === 5)) return false;
    if(p.color === 'black' && !(r === 7 || r === 8)) return false;
  }
  const occ = pieces.some(x=>!x.isCaptured && x.row===r&&x.col===c&&x.color===p.color && x.id!==p.id)
  if(occ)return false
  return true
}

function checkAllPiecesDeployed() {
  const my = isHost?'red':'black'
  const myps = pieces.filter(p=>p.color===my)
  const all = myps.every(p=>p.row!==-1&&p.col!==-1)
  const flagOk = myps.some(p=>p.name==='军旗'&&p.row!==-1&&p.col!==-1&&cells.some(c=>c.row===p.row&&c.col===p.col&&c.type==='H'))
  document.getElementById('btnConfirmDeploy').disabled = !(all&&flagOk)
}

function confirmDeploy() {
  deployComplete = true
  isDeployPhase = false
  document.getElementById('deployPanel').style.display='none'
  document.getElementById('deployTips').style.display='none'
  if(gameMode===1){
    const my = isHost?'red':'black'
    pieces.forEach(p=>{
      if(p.element){
        if(p.color===my) {p.element.innerText=p.name;p.isRevealed=true}
        else {p.element.remove();p.element=null;p.isRevealed=false}
      }
    })
  }
  showMessage('布阵完成，等待联机成功后开始游戏','success')
  updateStartButtonStatus()
  updateGameInfo()
}

function autoDeployPieces() {
  pieces.forEach(p=>{p.row=-1;p.col=-1})
  renderPieces()
}

function deployFlipPieces() {
  const sts = cells.filter(c=>c.type==='S').map(c=>({r:c.row,c:c.col})).sort(()=>Math.random()-0.5)
  pieces.forEach((p,i)=>{if(i<sts.length){p.row=sts[i].r;p.col=sts[i].c;p.isRevealed=false}})
  renderPieces()
}

function renderPieces() {
  document.querySelectorAll('.piece').forEach(p=>p.remove())
  const b=document.getElementById('board')
  pieces.filter(p=>!p.isCaptured).forEach(p=>{
    if(p.row===-1||p.col===-1)return
    const el=document.createElement('div')
    el.className=`piece ${p.color==='red'?'piece-red':'piece-black'}`
    if(gameMode===2) el.innerText=p.name
    else if(gameMode===1) el.innerText=(p.color===(isHost?'red':'black')||p.isRevealed)?p.name:'?'
    else if(gameMode===3) el.innerText=p.isRevealed?p.name:'?'
    if(!p.isMovable) el.classList.add('piece-fixed')
    if((gameMode===1||gameMode===3) && !((gameMode===1&&p.color===(isHost?'red':'black'))||(p.isRevealed))) el.className='piece piece-unknown'
    el.style.left=`${p.col*cellWidth+1}%`
    el.style.top=`${p.row*cellHeight+0.4}%`
    el.dataset.pieceId=p.id
    el.onclick=e=>{e.preventDefault();handlePieceClick(e,p)}
    b.appendChild(el)
    p.element=el
  })
}

function handlePieceClick(e,p) {
  if(gameOver||!deployComplete||!isConnected){
    showMessage(!isConnected ? '未联机，禁止操作' : '游戏未准备完成', 'warn');
    return
  }
  if(p.color!==currentTurn){showMessage('不是你的回合','warn');return}
  if(!p.isMovable){showMessage('不可移动','info');return}
  if(selectedPiece&&selectedPiece.element)selectedPiece.element.classList.remove('piece-selected')
  cells.forEach(c=>c.element.classList.remove('cell-selected'))
  selectedPiece=p
  p.element.classList.add('piece-selected')
  highlightMovableCells(p)
}

function highlightMovableCells(p) { 
  cells.forEach(c=>{
    if(validateMove(p,+c.dataset.row,+c.dataset.col)){
      c.element.classList.add('cell-selected')
    }
  }) 
}

function handleCellClick(cell) {
  if(!selectedPiece||gameOver||!deployComplete||!isConnected){
    showMessage(!isConnected ? '未联机，禁止操作' : '游戏未准备完成', 'warn');
    return
  }
  const tr=+cell.dataset.row,tc=+cell.dataset.col
  if(!validateMove(selectedPiece,tr,tc)){
    cells.forEach(c=>c.element.classList.remove('cell-selected'));
    selectedPiece.element.classList.remove('piece-selected');
    selectedPiece=null;
    return;
  }
  
  // 记录移动前的位置
  const oldRow = selectedPiece.row
  const oldCol = selectedPiece.col
  
  // 处理棋子对战
  const tgt=pieces.find(x=>!x.isCaptured&&x.row===tr&&x.col===tc&&x.color!==selectedPiece.color)
  if(tgt){
    const res=judgeBattle(selectedPiece,tgt)
    if(res==='win'){
      tgt.isCaptured=true;
      if(tgt.name==='军旗'){
        gameOver=true;
        showGameOver(selectedPiece.color);
        // 发送游戏结束消息
        sendGameMessage({ type: 'game_over', winner: selectedPiece.color })
        return;
      }
    }
    if(res==='lose') selectedPiece.isCaptured=true
    if(res==='draw'){
      selectedPiece.isCaptured=true;
      tgt.isCaptured=true;
    }
    if(gameMode===1)tgt.isRevealed=true
  }
  
  // 更新棋子位置
  selectedPiece.row=tr;
  selectedPiece.col=tc;
  
  // 发送棋子移动消息给对方
  sendGameMessage({
    type: 'piece_move',
    pieceId: selectedPiece.id,
    oldRow: oldRow,
    oldCol: oldCol,
    row: tr,
    col: tc
  })
  
  // 切换回合
  const newTurn = currentTurn === 'red' ? 'black' : 'red'
  currentTurn = newTurn
  
  // 发送回合切换消息
  sendGameMessage({ type: 'turn_change', turn: newTurn })
  
  // 刷新界面
  cells.forEach(c=>c.element.classList.remove('cell-selected'))
  selectedPiece.element.classList.remove('piece-selected')
  selectedPiece=null
  renderPieces()
  updateGameInfo()
}

function validateMove(p,tr,tc) {
  if(tr<0||tr>=13||tc<0||tc>=5)return false
  const ce=cells.find(x=>x.row===tr&&x.col===tc)
  if(!ce)return false
  if(ce.type==='F'&&!pieces.some(x=>x.row===tr&&x.col===tc&&x.color!==p.color))return false
  if(pieces.some(x=>!x.isCaptured&&x.row===tr&&x.col===tc&&x.color===p.color))return false
  const dr=Math.abs(tr-p.row),dc=Math.abs(tc-p.col)
  const road=(dr+dc)===1
  let rail=false
  if(p.name==='工兵')rail=(dr===0||dc===0)
  else rail=(dr===0||dc===0)
  return road||rail
}

function judgeBattle(a,d) {
  if(d.name==='军旗')return'win'
  if(a.name==='炸弹'||d.name==='炸弹')return'draw'
  if(d.name==='地雷')return a.name==='工兵'?'win':'lose'
  return PIECE_RANK[a.name]>PIECE_RANK[d.name]?'win':PIECE_RANK[a.name]<PIECE_RANK[d.name]?'lose':'draw'
}

function updateGameInfo() {
  document.getElementById('showMode').innerText = gameMode === 1 ? '暗棋' : gameMode === 2 ? '明棋' : '翻棋'
  document.getElementById('showTurn').innerText = currentTurn === 'red' ? '红方' : '黑方'
  document.getElementById('showConn').innerText = connMode === 3 ? '局域网点对点' : connMode === 4 ? '蓝牙' : '未选择'
  document.getElementById('showStatus').innerText = gameOver ? '游戏结束' : deployComplete ? '游戏中' : '布阵中'
}

function showGameOver(winner) {
  gameOver = true
  const overText = document.getElementById('overText')
  overText.innerText = `${winner === 'red' ? '红方' : '黑方'}胜利！`
  document.getElementById('overLayer').style.display = 'flex'
  updateGameInfo()
}

function restartGame() {
  // 断开局域网连接
  if (peerConnection) {
    peerConnection.destroy()
    peerConnection = null
  }
  // 断开蓝牙连接
  disconnectBluetooth()
  
  // 重置状态
  deployComplete = false
  gameOver = false
  currentTurn = 'red'
  updateConnectStatus('disconnected')
  
  // 刷新页面
  location.reload()
}
</script>
</body>
</html>
