<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>军棋对战（局域网专属版）</title>
<style>
/* 完整样式保留，仅适配局域网界面 */
*{box-sizing:border-box;margin:0;padding:0;font-family:Microsoft YaHei,sans-serif}
body{background:#f4f6f8;padding:10px}
.container{max-width:700px;margin:0 auto;background:#fff;border-radius:12px;padding:20px;box-shadow:0 2px 12px rgba(0,0,0,0.1)}
.title{text-align:center;font-size:24px;font-weight:bold;margin-bottom:16px;color:#222}
.btn-group{display:flex;justify-content:center;gap:10px;margin-bottom:12px;flex-wrap:wrap}
.btn{padding:10px 20px;border:none;border-radius:8px;background:#1677ff;color:#fff;font-size:15px;cursor:pointer;transition:background 0.2s}
.btn:hover{background:#096dd9}
.btn:disabled{background:#d9d9d9;cursor:not-allowed;color:#8c8c8c}
.btn-mode{background:#14c9c9}
.btn-start{background:#52c1a6}
.msg-box{text-align:center;padding:12px;border-radius:8px;margin:10px 0;font-size:15px}
.msg-info{background:#e6f7ff;color:#0066cc}
.msg-success{background:#f0fff4;color:#008800}
.msg-error{background:#fff1f0;color:#cc0000}
.msg-warn{background:#fffbe6;color:#faad14}
.panel{display:none;text-align:center;padding:16px;border:2px solid #1677ff;border-radius:8px;margin:10px auto;max-width:500px;background:#f7fcff}
.panel-title{font-size:16px;margin-bottom:12px;font-weight:bold}
.mode-panel{border-color:#14c9c9;background:#f0fefe}
.deploy-panel{border-color:#faad14;background:#fffbf5}
.conn-panel{border-color:#ff7d00;background:#fff9f0}
.lan-panel{display:none;text-align:center;padding:12px;border:2px solid #1677ff;border-radius:8px;margin:10px auto;max-width:400px;background:#f7fcff}
.lan-info{font-size:18px;font-weight:bold;color:#1677ff;margin:10px 0}
.lan-input{padding:8px 12px;border:2px solid #1677ff;border-radius:6px;font-size:16px;width:200px;margin-right:10px;text-align:center}
/* 新增连接码样式 */
.code-panel{margin:15px 0;padding:10px;background:#e6f7ff;border-radius:8px}
.code-title{font-weight:bold;margin-bottom:8px;color:#1677ff}
.code-display{padding:8px;font-size:14px;background:#fff;border:1px solid #1677ff;border-radius:4px;margin:8px 0;word-break:break-all}
.code-input{width:100%;padding:8px;margin:8px 0;border:2px solid #1677ff;border-radius:6px;text-align:center}
.bluetooth-panel{display:none;text-align:center;padding:12px;border:2px solid #ff7d00;background:#fff9f0;border-radius:8px;margin:10px auto;max-width:400px}
.bluetooth-device-list{max-height:150px;overflow-y:auto;margin:10px 0;text-align:left;padding:10px;border:1px solid #ddd;border-radius:6px}
.bluetooth-device-item{padding:6px;margin:4px 0;border-radius:4px;cursor:pointer}
.bluetooth-device-item:hover{background:#e6f7ff}
.connect-status{text-align:center;font-size:16px;margin:10px auto;padding:8px;border-radius:8px;max-width:400px;font-weight:bold}
.status-disconnected{background:#fff1f0;color:#cc0000}
.status-waiting{background:#f5f0ff;color:#722ed1}
.status-connecting{background:#fffbe6;color:#faad14}
.status-connected{background:#f0fff4;color:#008800}
.info-bar{display:flex;justify-content:space-between;max-width:650px;margin:10px auto;font-size:15px;padding:0 8px;flex-wrap:wrap;gap:10px}
.info-bar div{flex:1;min-width:120px;text-align:center}
.info-bar span{font-weight:bold;color:#1677ff}
.board-wrap{max-width:600px;margin:20px auto;position:relative}
.board{
  width:100%;
  aspect-ratio: 5 / 7;
  background:#fdfbf6;
  border:3px solid #333;
  position:relative;
  border-radius:4px;
  overflow:hidden;
}
.cell{
  position:absolute;
  width:20%;
  height:7.692%;
  display:flex;
  align-items:center;
  justify-content:center;
  font-size:11px;
  border:1px solid #999;
  background:#fff;
  z-index:1;
  cursor:pointer;
}
.cell-selected{
  background:#d4edda !important;
  border:2px solid #28a745 !important;
}
.cell-station{background:#fff;border:1px solid #999}
.cell-camp{background:#e0f0ff;border:2px solid #0066cc;border-radius:50%;z-index:2;font-weight:bold;color:#0066cc}
.cell-home{background:#ff4444;border:2px solid #cc0000;color:white;font-weight:bold;z-index:2}
.cell-front{background:#f0f0f0;border:2px solid #666;font-weight:bold;color:#333}
.piece{
  position:absolute;
  width:18%;
  height:6.8%;
  left:1%;
  top:0.4%;
  display:flex;
  align-items:center;
  justify-content:center;
  border-radius:6px;
  font-size:12px;
  font-weight:bold;
  border:2px solid #fff;
  cursor:pointer;
  z-index:5;
  box-shadow:0 1px 4px rgba(0,0,0,0.2);
  transition:transform 0.1s;
}
.piece-red{background:#e63946;color:#fff}
.piece-black{background:#222;color:#fff}
.piece-unknown{background:#bbb;color:#222;font-size:11px}
.piece-selected{
  transform:scale(1.1);
  border:3px solid #ffc107;
  box-shadow:0 0 10px rgba(255,193,7,0.8);
}
.piece-fixed{cursor:not-allowed;opacity:0.9}
.deploy-tips{
  position:absolute;
  top:10px;
  left:10px;
  background:rgba(0,0,0,0.7);
  color:white;
  padding:8px;
  border-radius:6px;
  font-size:12px;
  z-index:100;
  display:none;
}
.over-layer{
  position:absolute;
  top:0;
  left:0;
  width:100%;
  height:100%;
  background:rgba(0,0,0,0.7);
  display:none;
  flex-direction:column;
  align-items:center;
  justify-content:center;
  color:white;
  z-index:999;
  border-radius:4px;
}
.over-text{font-size:28px;font-weight:bold;margin-bottom:20px}
.over-btn{padding:12px 24px;background:#1677ff;color:white;border:none;border-radius:8px;cursor:pointer;font-size:16px}
</style>
</head>
<body>
<div class="container">
  <div class="title">军棋对战（局域网专属版）</div>
  <div class="btn-group">
    <button class="btn btn-mode" id="btnModeSelect">选择玩法模式</button>
    <button class="btn" id="btnHost">我是红方（主机）</button>
    <button class="btn" id="btnClient">我是黑方（客户端）</button>
    <button class="btn btn-start" id="btnStartGame" disabled>开始游戏</button>
  </div>
  <div class="msg-box msg-info" id="msgBox">请先选择玩法模式，再选择身份</div>
  
  <div class="connect-status status-disconnected" id="connectStatus">
    联机状态：未连接
  </div>
  
  <div class="panel mode-panel" id="modePanel">
    <div class="panel-title">选择对局玩法</div>
    <button class="btn" onclick="setGameMode(1)">暗棋（线下经典）</button>
    <button class="btn" onclick="setGameMode(2)">明棋（新手入门）</button>
    <button class="btn" onclick="setGameMode(3)">翻棋（线上主流）</button>
  </div>
  
  <div class="panel deploy-panel" id="deployPanel">
    <div class="panel-title">暗棋排兵布阵（遵循布局规则）</div>
    <div style="font-size:14px;color:#cc6600;margin-bottom:10px">
      规则提示：<br>
      1. 军旗必须放大本营 | 2. 炸弹不可放第一排 | 3. 地雷仅可放最后两排 | 4. 行营不可放棋子<br>
      操作：点击棋子选择，再次点击目标格子放置
    </div>
    <button class="btn" onclick="startDeploy()">进入布阵界面</button>
    <button class="btn" onclick="confirmDeploy()" disabled id="btnConfirmDeploy">确认布阵</button>
  </div>
  
  <!-- 局域网联机面板 -->
  <div class="panel conn-panel" id="connPanel">
    <div class="panel-title">选择局域网联机方式</div>
    <button class="btn" id="btnLanPeer" onclick="startHost(3)">局域网点对点联机（推荐）</button>
    <button class="btn" onclick="startHost(4)">蓝牙联机（需HTTPS/localhost）</button>
  </div>
  
  <!-- 红方主机局域网信息面板 -->
  <div class="lan-panel" id="hostLanPanel">
    <div class="panel-title">红方主机（局域网信息）</div>
    <div>本机局域网IP：</div>
    <div class="lan-info" id="hostIpInfo">检测中...</div>
    
    <!-- 新增连接码面板 -->
    <div class="code-panel">
      <div class="code-title">主机连接码（请告诉黑方）：</div>
      <div class="code-display" id="hostCodeDisplay">等待生成...</div>
      <button class="btn" onclick="copyHostCode()">复制连接码</button>
    </div>
    
    <div style="margin:10px 0">请将上方连接码发给黑方，黑方输入后即可连接</div>
    <button class="btn" onclick="startLanHost()">启动局域网联机服务</button>
  </div>
  
  <!-- 黑方客户端连接面板 -->
  <div class="lan-panel" id="clientLanPanel">
    <div class="panel-title">黑方客户端（连接主机）</div>
    <div>输入红方主机连接码：</div>
    <input type="text" class="code-input" id="hostCodeInput" placeholder="请输入主机提供的连接码">
    
    <!-- 可选：手动输入主机IP（备用） -->
    <div style="margin-top:15px">或手动输入主机IP：</div>
    <input type="text" class="lan-input" id="hostIpInput" placeholder="如：192.168.1.100" value="192.168.1.100">
    
    <button class="btn" onclick="connectLanClient()">连接主机</button>
  </div>
  
  <!-- 蓝牙面板保留 -->
  <div class="bluetooth-panel" id="bluetoothPanel">
    <div class="panel-title">蓝牙连接控制（真实API）</div>
    <button class="btn" onclick="scanBluetoothDevices()">扫描蓝牙设备</button>
    <div class="bluetooth-device-list" id="bluetoothDeviceList">
      请点击扫描按钮查找设备（需蓝牙开启）...
    </div>
    <button class="btn" style="margin-top:10px" onclick="connectBluetoothDevice()" disabled id="btnConnectBluetooth">连接选中设备</button>
    <button class="btn" style="margin-top:10px" onclick="disconnectBluetooth()">断开蓝牙连接</button>
  </div>
  
  <div class="info-bar">
    <div>当前玩法：<span id="showMode">未选择</span></div>
    <div>当前回合：<span id="showTurn">未开始</span></div>
    <div>通信模式：<span id="showConn">未选择</span></div>
    <div>游戏状态：<span id="showStatus">未开始</span></div>
  </div>
  
  <div class="board-wrap">
    <div class="board" id="board">
      <div class="deploy-tips" id="deployTips">排兵布阵中：点击棋子选择，再次点击目标格子放置</div>
      <div class="over-layer" id="overLayer">
        <div class="over-text" id="overText">红方胜利！</div>
        <button class="over-btn" onclick="restartGame()">重新开始</button>
      </div>
    </div>
  </div>
</div>

<!-- 内嵌 SimplePeer 核心库 -->
<script>
// SimplePeer 核心精简版（支持跨设备局域网通信）
(function(window) {
  window.SimplePeer = function(options) {
    this.options = options || {};
    this.initiator = this.options.initiator || false;
    this.trickle = this.options.trickle !== false;
    this.config = this.options.config || { 
      iceServers: [
        { urls: 'stun:stun.l.google.com:19302' } // 新增STUN服务器，确保局域网连接
      ] 
    };
    this.connected = false;
    this.destroyed = false;
    this.signalData = null; // 存储信号数据
    
    // 创建 RTCPeerConnection
    try {
      this._pc = new (window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection)(this.config);
    } catch (e) {
      console.error('创建RTCPeerConnection失败:', e);
      throw new Error('浏览器不支持WebRTC，请使用Chrome/Edge/Firefox');
    }
    
    // 创建数据通道（主机）
    if (!this.initiator) {
      this._dc = this._pc.createDataChannel('junqi-data', {
        ordered: true,
        maxRetransmits: 0
      });
      this._bindDataChannelEvents();
    } else {
      // 客户端监听数据通道
      this._pc.ondatachannel = (e) => {
        this._dc = e.channel;
        this._bindDataChannelEvents();
      };
    }
    
    // 绑定ICE事件
    this._bindIceEvents();
    
    // 内部事件系统
    this._events = {};
  };

  // 绑定数据通道事件
  window.SimplePeer.prototype._bindDataChannelEvents = function() {
    const self = this;
    
    this._dc.onopen = function() {
      self.connected = true;
      self.emit('connect');
    };
    
    this._dc.onmessage = function(e) {
      self.emit('data', e.data);
    };
    
    this._dc.onclose = function() {
      self.connected = false;
      self.emit('close');
    };
    
    this._dc.onerror = function(err) {
      self.emit('error', err);
    };
  };

  // 绑定ICE候选事件
  window.SimplePeer.prototype._bindIceEvents = function() {
    const self = this;
    
    this._pc.onicecandidate = function(e) {
      if (e.candidate && !self.destroyed) {
        self.signalData = self.signalData || {};
        self.signalData.candidate = e.candidate;
        
        // 生成完整的信号数据
        const signalObj = {
          type: 'candidate',
          candidate: e.candidate,
          sdp: self._pc.localDescription ? self._pc.localDescription.toJSON() : null
        };
        
        self.emit('signal', signalObj);
        self.signalData = signalObj;
      }
    };
    
    // 连接状态变化
    this._pc.onconnectionstatechange = function() {
      console.log('连接状态:', self._pc.connectionState);
      if (self._pc.connectionState === 'connected') {
        self.connected = true;
        self.emit('connect');
      } else if (self._pc.connectionState === 'failed' || self._pc.connectionState === 'closed') {
        self.connected = false;
        self.emit('close');
      }
    };
    
    this._pc.onerror = function(err) {
      self.emit('error', err);
    };
  };

  // 生成连接码
  window.SimplePeer.prototype.generateConnectCode = function() {
    return new Promise((resolve) => {
      const self = this;
      
      // 创建offer（主机）
      if (!this.initiator) {
        this._pc.createOffer({
          offerToReceiveAudio: false,
          offerToReceiveVideo: false
        }).then(offer => {
          return this._pc.setLocalDescription(offer);
        }).then(() => {
          // 生成连接码
          const code = btoa(JSON.stringify({
            sdp: this._pc.localDescription.toJSON(),
            ip: window.localLanIp || 'unknown'
          }));
          self.signalData = {
            sdp: this._pc.localDescription.toJSON()
          };
          resolve(code);
        }).catch(err => {
          console.error('生成offer失败:', err);
          self.emit('error', err);
          resolve(null);
        });
      } else {
        resolve(null); // 客户端不生成连接码
      }
    });
  };

  // 解析连接码
  window.SimplePeer.prototype.parseConnectCode = function(code) {
    try {
      const decoded = JSON.parse(atob(code));
      return decoded;
    } catch (e) {
      throw new Error('无效的连接码');
    }
  };

  // 发送信号
  window.SimplePeer.prototype.signal = function(data) {
    if (this.destroyed) return;
    
    try {
      if (data.sdp) {
        // 设置远程描述
        const desc = new RTCSessionDescription(data.sdp);
        this._pc.setRemoteDescription(desc).then(() => {
          // 客户端创建answer
          if (this.initiator) {
            this._pc.createAnswer().then(answer => {
              return this._pc.setLocalDescription(answer);
            }).then(() => {
              this.emit('signal', {
                type: 'answer',
                sdp: this._pc.localDescription.toJSON()
              });
            }).catch(err => {
              this.emit('error', err);
            });
          }
        }).catch(err => {
          this.emit('error', err);
        });
      }
      
      // 添加ICE候选
      if (data.candidate) {
        this._pc.addIceCandidate(new RTCIceCandidate(data.candidate))
          .catch(err => console.warn('添加ICE候选失败:', err));
      }
    } catch (err) {
      this.emit('error', err);
    }
  };

  // 发送数据
  window.SimplePeer.prototype.send = function(data) {
    if (!this.connected || this.destroyed || !this._dc) {
      this.emit('error', new Error('未连接或数据通道未就绪'));
      return;
    }
    
    try {
      this._dc.send(data);
    } catch (err) {
      this.emit('error', err);
    }
  };

  // 销毁连接
  window.SimplePeer.prototype.destroy = function() {
    if (this.destroyed) return;
    
    this.destroyed = true;
    this.connected = false;
    
    try {
      if (this._dc) this._dc.close();
      if (this._pc) this._pc.close();
    } catch (e) {}
    
    this.emit('close');
  };

  // 事件系统
  window.SimplePeer.prototype.on = function(event, fn) {
    if (!this._events[event]) this._events[event] = [];
    this._events[event].push(fn);
  };

  window.SimplePeer.prototype.emit = function(event, ...args) {
    if (this._events[event]) {
      this._events[event].forEach(fn => fn.apply(this, args));
    }
  };

  window.SimplePeer.prototype.off = function(event, fn) {
    if (this._events[event]) {
      this._events[event] = this._events[event].filter(f => f !== fn);
    }
  };

})(window);

// ===================== 全局配置 =====================
const CONN_MODE = { LAN_PEER:3, BLUETOOTH:4 }
const GAME_MODE = { DARK:1, BRIGHT:2, FLIP:3 }
const PIECE_RANK = {
  '司令':10, '军长':9, '师长':8, '旅长':7, '团长':6,
  '营长':5, '连长':4, '排长':3, '工兵':2, '炸弹':1,
  '地雷':0, '军旗':-1
}
const PIECE_CONFIG = [
  {name:'军旗', count:1, movable:false, deployRule:{mustHome:true}},
  {name:'地雷', count:3, movable:false, deployRule:{onlyLastTwoRows:true}},
  {name:'炸弹', count:2, movable:true, deployRule:{noFirstRow:true}},
  {name:'司令', count:1, movable:true, deployRule:{}},
  {name:'军长', count:1, movable:true, deployRule:{}},
  {name:'师长', count:2, movable:true, deployRule:{}},
  {name:'旅长', count:2, movable:true, deployRule:{}},
  {name:'团长', count:2, movable:true, deployRule:{}},
  {name:'营长', count:2, movable:true, deployRule:{}},
  {name:'连长', count:3, movable:true, deployRule:{}},
  {name:'排长', count:3, movable:true, deployRule:{}},
  {name:'工兵', count:3, movable:true, deployRule:{}}
]

// 全局状态
let gameMode = 0
let connMode = 0
let isHost = false
let localLanIp = '' 
let currentTurn = "red"
let gameOver = false
let selectedPiece = null
let pieces = []
let cells = []
let isDeployPhase = false
let deployComplete = false
let cellWidth = 20
let cellHeight = 100/13

// 联机状态
let connectStatus = 'disconnected'
let isConnected = false
let peerConnection = null
let bluetoothDevice = null
let selectedBluetoothDevice = null
window.localLanIp = ''; // 全局IP变量

// ===================== 页面初始化 =====================
window.onload = () => {
  document.getElementById('btnLanPeer').disabled = false;
  
  // 增强的局域网IP检测
  getLocalLanIp()
  buildStandardBoard()
  bindButtonEvents()
  updateConnectStatus(connectStatus)
  
  // 检查WebRTC支持
  if (!window.RTCPeerConnection) {
    showMessage('当前浏览器不支持WebRTC，无法进行局域网联机', 'error')
    document.getElementById('btnLanPeer').disabled = true
  }
  
  // 检查蓝牙支持
  if (!navigator.bluetooth) {
    showMessage('当前浏览器不支持蓝牙API', 'warn')
    document.querySelectorAll('.btn[onclick="startHost(4)"]')[0].disabled = true
  }
}

// ===================== 增强的局域网IP检测 =====================
function getLocalLanIp() {
  const ipInfoEl = document.getElementById('hostIpInfo')
  
  // 方法1：通过WebRTC获取
  const RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection;
  if (RTCPeerConnection) {
    const pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });
    
    // 创建虚拟数据流触发ICE
    pc.createDataChannel('');
    pc.createOffer().then(offer => {
      return pc.setLocalDescription(offer);
    }).catch(err => {
      console.error('获取IP失败:', err);
      fallbackIpDetection();
    });
    
    // 监听ICE候选提取IP
    pc.onicecandidate = (e) => {
      if (!e.candidate) return;
      
      // 提取所有可能的IP
      const ipRegex = /(192\.168\.\d+\.\d+|172\.1[6-9]\.\d+\.\d+|172\.2[0-9]\.\d+\.\d+|172\.3[0-1]\.\d+\.\d+|10\.\d+\.\d+\.\d+)/g;
      const ipMatches = e.candidate.candidate.match(ipRegex);
      
      if (ipMatches && ipMatches.length > 0) {
        // 去重并获取第一个有效IP
        const uniqueIps = [...new Set(ipMatches)];
        localLanIp = uniqueIps[0];
        window.localLanIp = localLanIp;
        ipInfoEl.innerText = localLanIp;
        
        // 显示所有检测到的IP
        if (uniqueIps.length > 1) {
          ipInfoEl.title = `检测到多个IP: ${uniqueIps.join(', ')}`;
        }
        
        pc.close();
      }
    };
    
    // 超时降级
    setTimeout(() => {
      if (!localLanIp) {
        fallbackIpDetection();
      }
    }, 5000);
    
  } else {
    fallbackIpDetection();
  }
  
  // 降级IP检测
  function fallbackIpDetection() {
    localLanIp = '192.168.1.100';
    window.localLanIp = localLanIp;
    ipInfoEl.innerText = localLanIp;
    showMessage('自动检测IP失败，使用默认IP，请手动确认', 'warn');
  }
}

// ===================== 联机状态管理 =====================
function updateConnectStatus(status) {
  connectStatus = status
  const statusEl = document.getElementById('connectStatus')
  statusEl.className = `connect-status status-${status}`
  
  const statusTextMap = {
    disconnected: '联机状态：未连接',
    waiting: '联机状态：等待客户端连接（主机）',
    connecting: '联机状态：正在连接...',
    connected: '联机状态：已连接（局域网）'
  }
  statusEl.innerText = statusTextMap[status]
  isConnected = status === 'connected'
  updateStartButtonStatus()
}

function updateStartButtonStatus() {
  document.getElementById('btnStartGame').disabled = !(deployComplete && isConnected)
}

function showMessage(text, type = 'info') {
  const msgBox = document.getElementById('msgBox')
  msgBox.innerText = text
  msgBox.className = `msg-box msg-${type}`
  
  // 重要提示不自动消失
  if (type !== 'info' || text.includes('连接码') || text.includes('IP')) {
    return;
  }
  
  setTimeout(() => {
    if (msgBox.innerText === text && connectStatus !== 'waiting') {
      msgBox.className = 'msg-box msg-info'
      msgBox.innerText = '等待操作...'
    }
  }, 3000)
}

// ===================== 核心：跨设备局域网联机 =====================
/**
 * 主机启动服务（生成连接码）
 */
async function startLanHost() {
  try {
    // 关闭旧连接
    if (peerConnection) {
      peerConnection.destroy()
      peerConnection = null
    }
    
    // 创建主机端Peer
    peerConnection = new window.SimplePeer({
      initiator: false, // 主机作为被动方
      trickle: true
    })
    
    // 生成连接码
    const hostCode = await peerConnection.generateConnectCode();
    if (!hostCode) {
      showMessage('生成连接码失败', 'error');
      return;
    }
    
    // 显示连接码
    document.getElementById('hostCodeDisplay').innerText = hostCode;
    
    // 更新状态
    updateConnectStatus('waiting')
    showMessage(`主机已启动！连接码：${hostCode}，请发给黑方`, 'success')
    
    // 监听连接事件
    peerConnection.on('connect', () => {
      updateConnectStatus('connected')
      showMessage('黑方已成功连接！', 'success')
    })
    
    // 监听消息
    peerConnection.on('data', (data) => {
      try {
        const msg = JSON.parse(data)
        handleGameMessage(msg)
      } catch (e) {
        console.error('解析消息失败:', e);
      }
    })
    
    // 监听错误
    peerConnection.on('error', (err) => {
      showMessage(`主机错误: ${err.message}`, 'error')
      console.error('Peer错误:', err);
    })
    
    // 监听断开
    peerConnection.on('close', () => {
      showMessage('连接已断开', 'warn')
      updateConnectStatus('disconnected')
    })
    
  } catch (e) {
    showMessage(`启动主机失败: ${e.message}`, 'error')
    console.error('启动主机失败:', e);
    updateConnectStatus('disconnected')
  }
}

/**
 * 客户端连接主机
 */
async function connectLanClient() {
  try {
    const hostCode = document.getElementById('hostCodeInput').value.trim()
    const hostIp = document.getElementById('hostIpInput').value.trim()
    
    // 验证输入
    if (!hostCode && !hostIp) {
      showMessage('请输入主机连接码或IP', 'error')
      return
    }
    
    // 关闭旧连接
    if (peerConnection) {
      peerConnection.destroy()
      peerConnection = null
    }
    
    // 更新状态
    updateConnectStatus('connecting')
    showMessage('正在连接主机...', 'info')
    
    // 创建客户端Peer
    peerConnection = new window.SimplePeer({
      initiator: true, // 客户端作为主动方
      trickle: true
    })
    
    // 如果有连接码，解析并连接
    if (hostCode) {
      try {
        const codeData = peerConnection.parseConnectCode(hostCode);
        peerConnection.signal(codeData);
        showMessage('正在使用连接码连接...', 'info');
      } catch (e) {
        showMessage(`无效的连接码: ${e.message}`, 'error');
        updateConnectStatus('disconnected');
        return;
      }
    }
    
    // 监听连接成功
    peerConnection.on('connect', () => {
      updateConnectStatus('connected')
      showMessage(`成功连接到主机！`, 'success')
    })
    
    // 监听信号生成（客户端需要发送answer）
    peerConnection.on('signal', (data) => {
      console.log('客户端信号:', data);
    })
    
    // 监听消息
    peerConnection.on('data', (data) => {
      try {
        const msg = JSON.parse(data)
        handleGameMessage(msg)
      } catch (e) {
        console.error('解析消息失败:', e);
      }
    })
    
    // 监听错误
    peerConnection.on('error', (err) => {
      showMessage(`连接错误: ${err.message}`, 'error')
      console.error('客户端错误:', err);
      updateConnectStatus('disconnected')
    })
    
    // 监听断开
    peerConnection.on('close', () => {
      showMessage('与主机的连接已断开', 'warn')
      updateConnectStatus('disconnected')
    })
    
    // 超时检测
    setTimeout(() => {
      if (connectStatus === 'connecting' && !peerConnection.connected) {
        showMessage('连接超时，请检查：1.连接码是否正确 2.是否在同一局域网 3.防火墙是否关闭', 'error')
        updateConnectStatus('disconnected')
      }
    }, 10000);
    
  } catch (e) {
    showMessage(`连接失败: ${e.message}`, 'error')
    console.error('连接主机失败:', e);
    updateConnectStatus('disconnected')
  }
}

/**
 * 复制主机连接码
 */
function copyHostCode() {
  const codeText = document.getElementById('hostCodeDisplay').innerText;
  if (codeText === '等待生成...' || !codeText) {
    showMessage('连接码尚未生成', 'warn');
    return;
  }
  
  navigator.clipboard.writeText(codeText).then(() => {
    showMessage('连接码已复制到剪贴板', 'success');
  }).catch(() => {
    // 降级方案
    const textArea = document.createElement('textarea');
    textArea.value = codeText;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    showMessage('连接码已复制', 'success');
  });
}

/**
 * 发送游戏消息
 */
function sendGameMessage(data) {
  if (!peerConnection || !peerConnection.connected) {
    showMessage('未连接到主机，无法发送消息', 'error')
    return
  }
  
  try {
    peerConnection.send(JSON.stringify({
      from: isHost ? 'red' : 'black',
      data: data
    }))
  } catch (e) {
    showMessage(`发送消息失败: ${e.message}`, 'error');
  }
}

/**
 * 处理游戏消息
 */
function handleGameMessage(msg) {
  try {
    if (!msg || !msg.data) return;
    
    if (msg.data.type === 'piece_move') {
      const piece = pieces.find(p => p.id === msg.data.pieceId)
      if (piece) {
        piece.row = msg.data.row
        piece.col = msg.data.col
        renderPieces()
      }
    }
    
    if (msg.data.type === 'turn_change') {
      currentTurn = msg.data.turn
      updateGameInfo()
      showMessage(`回合切换：${currentTurn === 'red' ? '红方' : '黑方'}行动`, 'info')
    }
    
    if (msg.data.type === 'game_over') {
      gameOver = true
      showGameOver(msg.data.winner)
    }
    
    if (msg.data.type === 'game_start') {
      currentTurn = msg.data.turn
      updateGameInfo()
      renderPieces()
    }
  } catch (e) {
    console.error('处理消息失败:', e);
    showMessage('处理游戏消息出错', 'error');
  }
}

// ===================== 蓝牙功能（保留） =====================
async function scanBluetoothDevices() {
  try {
    showMessage('正在扫描蓝牙设备，请允许权限', 'info')
    const deviceListEl = document.getElementById('bluetoothDeviceList')
    deviceListEl.innerHTML = '扫描中...'
    
    const devices = await navigator.bluetooth.requestDevice({
      acceptAllDevices: true,
      optionalServices: ['generic_access']
    })
    
    deviceListEl.innerHTML = ''
    const deviceItem = document.createElement('div')
    deviceItem.className = 'bluetooth-device-item'
    deviceItem.innerText = `设备名称：${devices.name || '未知设备'} | ID：${devices.id}`
    deviceItem.dataset.deviceId = devices.id
    deviceItem.onclick = () => {
      document.querySelectorAll('.bluetooth-device-item').forEach(i => i.style.background = '')
      deviceItem.style.background = '#1677ff'
      deviceItem.style.color = '#fff'
      selectedBluetoothDevice = devices
      document.getElementById('btnConnectBluetooth').disabled = false
      showMessage(`已选中蓝牙设备：${devices.name || '未知设备'}`, 'info')
    }
    deviceListEl.appendChild(deviceItem)
    
    showMessage('蓝牙设备扫描完成', 'success')
  } catch (err) {
    showMessage(`蓝牙扫描失败: ${err.message}`, 'error')
  }
}

async function connectBluetoothDevice() {
  if (!selectedBluetoothDevice) {
    showMessage('请先选择蓝牙设备', 'error')
    return
  }
  
  try {
    updateConnectStatus('connecting')
    showMessage(`正在连接蓝牙设备...`, 'info')
    
    const bluetoothServer = await selectedBluetoothDevice.gatt.connect()
    bluetoothDevice = selectedBluetoothDevice
    
    updateConnectStatus('connected')
    showMessage(`蓝牙设备连接成功`, 'success')
    
    selectedBluetoothDevice.addEventListener('gattserverdisconnected', () => {
      showMessage('蓝牙设备已断开', 'warn')
      disconnectBluetooth()
    })
  } catch (err) {
    showMessage(`蓝牙连接失败: ${err.message}`, 'error')
    updateConnectStatus('disconnected')
  }
}

function disconnectBluetooth() {
  try {
    if (bluetoothDevice && bluetoothDevice.gatt.connected) {
      bluetoothDevice.gatt.disconnect()
    }
    bluetoothDevice = null
    selectedBluetoothDevice = null
    updateConnectStatus('disconnected')
    document.getElementById('btnConnectBluetooth').disabled = true
    showMessage('已断开蓝牙连接', 'info')
  } catch (err) {
    showMessage(`断开蓝牙失败: ${err.message}`, 'error')
  }
}

// ===================== 棋盘和游戏逻辑（保留） =====================
function buildStandardBoard() {
  const board = document.getElementById('board')
  board.innerHTML = `
    <div class="deploy-tips" id="deployTips">排兵布阵中：点击棋子选择，再次点击目标格子放置</div>
    <div class="over-layer" id="overLayer">
      <div class="over-text" id="overText">红方胜利！</div>
      <button class="over-btn" onclick="restartGame()">重新开始</button>
    </div>
  `;
  
  cells = []
  cellWidth = 20
  cellHeight = 100/13
  let cellId = 0

  const BOARD_LAYOUT = [
    ['S','H','S','H','S'],
    ['S','S','S','S','S'],
    ['S','C','S','C','S'],
    ['S','S','C','S','S'],
    ['S','C','S','C','S'],
    ['S','S','S','S','S'],
    ['F','F','F','F','F'],
    ['S','S','S','S','S'],
    ['S','C','S','C','S'],
    ['S','S','C','S','S'],
    ['S','C','S','C','S'],
    ['S','S','S','S','S'],
    ['S','H','S','H','S']
  ]

  for (let row = 0; row < 13; row++) {
    for (let col = 0; col < 5; col++) {
      const cellType = BOARD_LAYOUT[row][col]
      const cell = document.createElement('div')
      cell.className = 'cell'
      cell.style.left = `${col * cellWidth}%`
      cell.style.top = `${row * cellHeight}%`
      cell.dataset.type = cellType
      cell.dataset.row = row
      cell.dataset.col = col
      cell.dataset.id = cellId

      if (cellType === 'S') { cell.className += ' cell-station'; cell.innerText = '兵站' }
      if (cellType === 'C') { cell.className += ' cell-camp'; cell.innerText = '行营' }
      if (cellType === 'H') { cell.className += ' cell-home'; cell.innerText = '大本营' }
      if (cellType === 'F') { cell.className += ' cell-front'; cell.innerText = (col===1)?'红\n方':(col===3)?'黑\n方':'前线' }

      cell.onclick = () => {
        if (isDeployPhase) handleDeployCellClick(cell)
        else handleCellClick(cell)
      }

      board.appendChild(cell)
      cells.push({ id:cellId, row, col, type:cellType, element:cell, isRedArea:row<6, isBlackArea:row>6, isPublicArea:row===6 })
      cellId++
    }
  }
}

function bindButtonEvents() {
  document.getElementById('btnModeSelect').onclick = () => {
    document.getElementById('modePanel').style.display = 'block'
    showMessage('请选择游戏玩法模式','info')
  }
  
  document.getElementById('btnHost').onclick = () => {
    isHost = true
    document.getElementById('connPanel').style.display = 'block'
    document.getElementById('hostLanPanel').style.display = 'block'
    document.getElementById('clientLanPanel').style.display = 'none'
    document.getElementById('bluetoothPanel').style.display = 'none'
    showMessage('你是红方（主机），请启动联机服务', 'info')
    updateGameInfo()
  }
  
  document.getElementById('btnClient').onclick = () => {
    isHost = false
    document.getElementById('connPanel').style.display = 'block'
    document.getElementById('hostLanPanel').style.display = 'none'
    document.getElementById('clientLanPanel').style.display = 'block'
    document.getElementById('bluetoothPanel').style.display = 'none'
    showMessage('你是黑方（客户端），请输入主机连接码', 'info')
    updateGameInfo()
  }
  
  document.getElementById('btnStartGame').onclick = () => {
    if (!gameOver && deployComplete && isConnected) {
      showMessage('游戏开始！红方先行','success')
      currentTurn = 'red'
      updateGameInfo()
      renderPieces()
      sendGameMessage({ type: 'game_start', turn: 'red' })
    }
  }
}

function setGameMode(mode) {
  gameMode = mode
  document.getElementById('modePanel').style.display = 'none'
  initPieces()
  showMessage(`已选择${mode===1?'暗棋':mode===2?'明棋':'翻棋'}模式`,'success')
  updateGameInfo()
}

function startHost(mode) {
  connMode = mode
  document.getElementById('connPanel').style.display = 'none'
  
  if (mode === CONN_MODE.LAN_PEER) {
    if (isHost) {
      document.getElementById('hostLanPanel').style.display = 'block'
    } else {
      document.getElementById('clientLanPanel').style.display = 'block'
    }
    showMessage(`已选择局域网点对点联机`, 'success')
  } else if (mode === CONN_MODE.BLUETOOTH) {
    document.getElementById('bluetoothPanel').style.display = 'block'
    showMessage(`已选择蓝牙联机`, 'success')
  }
  
  updateGameInfo()
}

function initPieces() {
  pieces = []
  let pid = 0
  PIECE_CONFIG.forEach(c=>{for(let i=0;i<c.count;i++)pieces.push({id:pid++,color:'red',name:c.name,row:-1,col:-1,isCaptured:false,isMovable:c.movable,isRevealed:gameMode===2,deployRule:c.deployRule})})
  PIECE_CONFIG.forEach(c=>{for(let i=0;i<c.count;i++)pieces.push({id:pid++,color:'black',name:c.name,row:-1,col:-1,isCaptured:false,isMovable:c.movable,isRevealed:gameMode===2,deployRule:c.deployRule})})

  if(gameMode===3){
    deployFlipPieces();
    deployComplete=true;
    updateStartButtonStatus()
  } else {
    gameMode===1?showDeployPanel():autoDeployPieces();
    deployComplete=gameMode===2;
    updateStartButtonStatus()
  }
}

function showDeployPanel() {
  document.getElementById('deployPanel').style.display = 'block'
  document.getElementById('deployTips').style.display = 'block'
  isDeployPhase = true
  showMessage('进入布阵阶段', 'info')
}

function startDeploy() {
  document.querySelectorAll('.piece').forEach(p=>p.remove())
  const my = isHost?'red':'black'
  my==='red' ? deployRedPiecesForDeploy() : deployBlackPiecesForDeploy()
  showMessage('点击棋子可重新放置', 'info')
}

function deployRedPiecesForDeploy() {
  const board = document.getElementById('board')
  let sx = 5, sy = 70
  pieces.filter(p=>p.color==='red').forEach((p,idx)=>{
    if(p.element)p.element.remove()
    const el = document.createElement('div')
    el.className = 'piece piece-red'
    el.innerText = p.name
    if(p.row === -1 || p.col === -1){
      el.style.left = `${sx + (idx%5)*18}%`
      el.style.top = `${sy + Math.floor(idx/5)*7}%`
    }else{
      el.style.left = `${p.col*cellWidth+1}%`
      el.style.top = `${p.row*cellHeight+0.4}%`
    }
    el.dataset.pieceId = p.id
    el.onclick = e=>{e.preventDefault();handleDeployPieceClick(p)}
    board.appendChild(el)
    p.element = el
  })
}

function deployBlackPiecesForDeploy() {
  const board = document.getElementById('board')
  let sx =5, sy=5
  pieces.filter(p=>p.color==='black').forEach((p,idx)=>{
    if(p.element)p.element.remove()
    const el = document.createElement('div')
    el.className = 'piece piece-black'
    el.innerText = p.name
    if(p.row === -1 || p.col === -1){
      el.style.left = `${sx + (idx%5)*18}%`
      el.style.top = `${sy + Math.floor(idx/5)*7}%`
    }else{
      el.style.left = `${p.col*cellWidth+1}%`
      el.style.top = `${p.row*cellHeight+0.4}%`
    }
    el.dataset.pieceId = p.id
    el.onclick = e=>{e.preventDefault();handleDeployPieceClick(p)}
    board.appendChild(el)
    p.element = el
  })
}

function handleDeployPieceClick(piece) {
  if(!isDeployPhase)return
  if(selectedPiece && selectedPiece.element) selectedPiece.element.classList.remove('piece-selected')
  selectedPiece = piece
  if(piece.element) piece.element.classList.add('piece-selected')
  showMessage(`已选中【${piece.name}】`, 'info')
}

function handleDeployCellClick(cell) {
  if(!isDeployPhase || !selectedPiece)return
  const tr = +cell.dataset.row
  const tc = +cell.dataset.col

  if(!validateDeployRule(selectedPiece, tr, tc)){
    showMessage('不符合布阵规则', 'error')
    return
  }

  selectedPiece.row = tr
  selectedPiece.col = tc
  selectedPiece.element.style.left = `${tc*cellWidth+1}%`
  selectedPiece.element.style.top = `${tr*cellHeight+0.4}%`
  selectedPiece.element.classList.remove('piece-selected')
  selectedPiece = null
  showMessage('棋子已放置', 'success')
  checkAllPiecesDeployed()
}

function validateDeployRule(p, r, c) {
  if(r<0||r>=13||c<0||c>=5)return false
  const redSide = r<6, blackSide=r>6
  if(p.color==='red'&&!redSide || p.color==='black'&&!blackSide)return false
  const cell = cells.find(x=>x.row===r&&x.col===c)
  if(!cell || cell.type==='C'||cell.type==='F')return false
  
  if(p.name === '军旗' && cell.type !== 'H') return false
  if(p.name === '炸弹') {
    if((p.color === 'red' && r === 0) || (p.color === 'black' && r === 12)) return false
  }
  if(p.name === '地雷') {
    if(p.color === 'red' && !(r === 4 || r === 5)) return false;
    if(p.color === 'black' && !(r === 7 || r === 8)) return false;
  }
  const occ = pieces.some(x=>!x.isCaptured && x.row===r&&x.col===c&&x.color===p.color && x.id!==p.id)
  if(occ)return false
  return true
}

function checkAllPiecesDeployed() {
  const my = isHost?'red':'black'
  const myps = pieces.filter(p=>p.color===my)
  const all = myps.every(p=>p.row!==-1&&p.col!==-1)
  const flagOk = myps.some(p=>p.name==='军旗'&&p.row!==-1&&p.col!==-1&&cells.some(c=>c.row===p.row&&c.col===p.col&&c.type==='H'))
  document.getElementById('btnConfirmDeploy').disabled = !(all&&flagOk)
}

function confirmDeploy() {
  deployComplete = true
  isDeployPhase = false
  document.getElementById('deployPanel').style.display='none'
  document.getElementById('deployTips').style.display='none'
  
  if(gameMode===1){
    const my = isHost?'red':'black'
    pieces.forEach(p=>{
      if(p.element){
        if(p.color===my) {p.element.innerText=p.name;p.isRevealed=true}
        else {p.element.remove();p.element=null;p.isRevealed=false}
      }
    })
  }
  
  showMessage('布阵完成，等待联机后开始游戏', 'success')
  updateStartButtonStatus()
  updateGameInfo()
}

function autoDeployPieces() {
  pieces.forEach(p=>{p.row=-1;p.col=-1})
  renderPieces()
}

function deployFlipPieces() {
  const sts = cells.filter(c=>c.type==='S').map(c=>({r:c.row,c:c.col})).sort(()=>Math.random()-0.5)
  pieces.forEach((p,i)=>{if(i<sts.length){p.row=sts[i].r;p.col=sts[i].c;p.isRevealed=false}})
  renderPieces()
}

function renderPieces() {
  document.querySelectorAll('.piece').forEach(p=>p.remove())
  const b=document.getElementById('board')
  
  pieces.filter(p=>!p.isCaptured).forEach(p=>{
    if(p.row===-1||p.col===-1)return
    
    const el=document.createElement('div')
    el.className=`piece ${p.color==='red'?'piece-red':'piece-black'}`
    
    if(gameMode===2) el.innerText=p.name
    else if(gameMode===1) el.innerText=(p.color===(isHost?'red':'black')||p.isRevealed)?p.name:'?'
    else if(gameMode===3) el.innerText=p.isRevealed?p.name:'?'
    
    if(!p.isMovable) el.classList.add('piece-fixed')
    if((gameMode===1||gameMode===3) && !((gameMode===1&&p.color===(isHost?'red':'black'))||(p.isRevealed))) {
      el.className='piece piece-unknown'
    }
    
    el.style.left=`${p.col*cellWidth+1}%`
    el.style.top=`${p.row*cellHeight+0.4}%`
    el.dataset.pieceId=p.id
    el.onclick=e=>{e.preventDefault();handlePieceClick(e,p)}
    
    b.appendChild(el)
    p.element=el
  })
}

function handlePieceClick(e,p) {
  if(gameOver||!deployComplete||!isConnected){
    showMessage(!isConnected ? '未联机，禁止操作' : '游戏未准备完成', 'warn');
    return
  }
  
  if(p.color!==currentTurn){
    showMessage('不是你的回合', 'warn');
    return
  }
  
  if(!p.isMovable){
    showMessage('该棋子不可移动', 'info');
    return
  }
  
  if(selectedPiece&&selectedPiece.element)selectedPiece.element.classList.remove('piece-selected')
  cells.forEach(c=>c.element.classList.remove('cell-selected'))
  
  selectedPiece=p
  p.element.classList.add('piece-selected')
  highlightMovableCells(p)
}

function highlightMovableCells(p) { 
  cells.forEach(c=>{
    if(validateMove(p,+c.dataset.row,+c.dataset.col)){
      c.element.classList.add('cell-selected')
    }
  }) 
}

function handleCellClick(cell) {
  if(!selectedPiece||gameOver||!deployComplete||!isConnected){
    showMessage(!isConnected ? '未联机，禁止操作' : '游戏未准备完成', 'warn');
    return
  }
  
  const tr=+cell.dataset.row,tc=+cell.dataset.col
  
  if(!validateMove(selectedPiece,tr,tc)){
    cells.forEach(c=>c.element.classList.remove('cell-selected'));
    selectedPiece.element.classList.remove('piece-selected');
    selectedPiece=null;
    return;
  }
  
  // 记录原位置
  const oldRow = selectedPiece.row
  const oldCol = selectedPiece.col
  
  // 处理对战
  const tgt=pieces.find(x=>!x.isCaptured&&x.row===tr&&x.col===tc&&x.color!==selectedPiece.color)
  if(tgt){
    const res=judgeBattle(selectedPiece,tgt)
    
    if(res==='win'){
      tgt.isCaptured=true;
      if(tgt.name==='军旗'){
        gameOver=true;
        showGameOver(selectedPiece.color);
        sendGameMessage({ type: 'game_over', winner: selectedPiece.color })
        return;
      }
    }
    
    if(res==='lose') selectedPiece.isCaptured=true
    if(res==='draw'){
      selectedPiece.isCaptured=true;
      tgt.isCaptured=true;
    }
    
    if(gameMode===1)tgt.isRevealed=true
  }
  
  // 更新位置
  selectedPiece.row=tr;
  selectedPiece.col=tc;
  
  // 发送移动消息
  sendGameMessage({
    type: 'piece_move',
    pieceId: selectedPiece.id,
    oldRow: oldRow,
    oldCol: oldCol,
    row: tr,
    col: tc
  })
  
  // 切换回合
  const newTurn = currentTurn === 'red' ? 'black' : 'red'
  currentTurn = newTurn
  
  // 发送回合消息
  sendGameMessage({ type: 'turn_change', turn: newTurn })
  
  // 刷新界面
  cells.forEach(c=>c.element.classList.remove('cell-selected'))
  selectedPiece.element.classList.remove('piece-selected')
  selectedPiece=null
  
  renderPieces()
  updateGameInfo()
}

function validateMove(p,tr,tc) {
  if(tr<0||tr>=13||tc<0||tc>=5)return false
  const ce=cells.find(x=>x.row===tr&&x.col===tc)
  if(!ce)return false
  
  if(ce.type==='F'&&!pieces.some(x=>x.row===tr&&x.col===tc&&x.color!==p.color))return false
  if(pieces.some(x=>!x.isCaptured&&x.row===tr&&x.col===tc&&x.color===p.color))return false
  
  const dr=Math.abs(tr-p.row),dc=Math.abs(tc-p.col)
  const road=(dr+dc)===1
  let rail=false
  
  if(p.name==='工兵')rail=(dr===0||dc===0)
  else rail=(dr===0||dc===0)
  
  return road||rail
}

function judgeBattle(a,d) {
  if(d.name==='军旗')return'win'
  if(a.name==='炸弹'||d.name==='炸弹')return'draw'
  if(d.name==='地雷')return a.name==='工兵'?'win':'lose'
  
  return PIECE_RANK[a.name]>PIECE_RANK[d.name]?'win':PIECE_RANK[a.name]<PIECE_RANK[d.name]?'lose':'draw'
}

function updateGameInfo() {
  document.getElementById('showMode').innerText = gameMode === 1 ? '暗棋' : gameMode === 2 ? '明棋' : '翻棋'
  document.getElementById('showTurn').innerText = currentTurn === 'red' ? '红方' : '黑方'
  document.getElementById('showConn').innerText = connMode === 3 ? '局域网点对点' : connMode === 4 ? '蓝牙' : '未选择'
  document.getElementById('showStatus').innerText = gameOver ? '游戏结束' : deployComplete ? '游戏中' : '布阵中'
}

function showGameOver(winner) {
  gameOver = true
  const overText = document.getElementById('overText')
  overText.innerText = `${winner === 'red' ? '红方' : '黑方'}胜利！`
  document.getElementById('overLayer').style.display = 'flex'
  updateGameInfo()
}

function restartGame() {
  // 断开连接
  if (peerConnection) {
    peerConnection.destroy()
    peerConnection = null
  }
  disconnectBluetooth()
  
  // 重置状态
  deployComplete = false
  gameOver = false
  currentTurn = 'red'
  updateConnectStatus('disconnected')
  
  // 刷新页面
  location.reload()
}
</script>
</body>
</html>
